<script>
    // Adds tags to the top of documentation pages for common Bevy traits
    // that are implemented by the current type, like `Component` or `Resource`.
    // This makes it easier to see at a glance what types are used for.
    //
    // This extension should be passed to `rustdoc` using the `--html-after-content` flag.

    // Traits that we want to show as tags.
    const bevyTraits = new Set(['Component', 'Resource', 'Event', 'Plugin']);    

    // Find all traits that are implemented by the current type.
    const implementedTraits = findImplementedTraits().entries();

    // Filter out any traits that are not in the set of Bevy traits we care about.
    const implementedBevyTraits = new Map(
        [...implementedTraits].filter(([traitName, _]) => bevyTraits.has(traitName))
    );

    // If we found any implemented traits, add them as tags to the top of the page.
    if (implementedBevyTraits.size > 0) {
        // Create a container for the tags.
        const heading = document.body.querySelector(".main-heading h1");
        const tagContainer = document.createElement('div');
        tagContainer.className = 'bevy-tag-container';
        heading.appendChild(tagContainer);

        // Create a tag for each implemented trait.
        for (const [traitName, href] of implementedBevyTraits) {
            // Every `Event` also implements `Component`, but it is extremely rare
            // to actually use events as components, so we skip the component tag for them.
            if (traitName == 'Component' && implementedBevyTraits.has('Event')) {
                continue;
            }

            // Create the tag and append it to the container.
            tagContainer.appendChild(createBevyTag(traitName, href));
        }
    }

    function findImplementedTraits() {
        // Traits that are implemented by the current type.
        // The key is the trait name, and the value is the href to the trait's documentation.
        const implementedTraits = new Map();

        // Find all trait implementation headers.
        const allTraitHeaders = document.body.querySelectorAll(
            '#trait-implementations-list .impl .code-header, #blanket-implementations-list .impl .code-header'
        );

        for (const header of allTraitHeaders) {
            let traitName;
            let href;

            // Find the trait link element if it exists.
            // Otherwise, the trait is just in plain text.
            const traitLinkEl = header.children[0];
            
            if (traitLinkEl?.classList.contains('trait')) {
                href = traitLinkEl.getAttribute('href');
                
                // The href is of the form 'path/to/trait.TraitName.html'.
                const parts = href.split('.');
                traitName = parts[parts.length - 2];
            } else {
                // The trait link is not available, so it's just in plain text
                // in the form 'impl TraitName for Type'.
                //
                // We can extract the trait name by removing any generics and splitting the string by spaces.
                traitName = removeGenerics(header.innerText).split(' ')[1].trim();
            }

            implementedTraits.set(traitName, href);
        }

        return implementedTraits;
    }
    
    // Helper function to remove generics from a string of Rust code.
    // For example, 'Vec<T>' would become 'Vec'.
    function removeGenerics(str) {
        // Remove the innermost generics.
        const newStr = str.replace(/<([^<>])*>/g, '');
        
        // If there are still generics, perform the removal again recursively.
        if (newStr !== str) {
            return removeGenerics(newStr);
        }

        // No more generics to remove.
        return newStr;
    }

    // Helper function to create a tag element with the given name and href,
    // if available.
    function createBevyTag(tagName, href) {
        const el = document.createElement('a');
        
        if (href) {
            el.setAttribute('href', href);
        }

        el.innerText = tagName;
        el.className = `bevy-tag ${tagName.toLowerCase()}-tag`;
        return el;
    }
</script>

<style>
    .bevy-tag-container {
        padding: 0.5rem 0;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .bevy-tag {
        display: flex;
        align-items: center;
        width: fit-content;
        height: 1.5rem;
        padding: 0 0.5rem;
        border-radius: 0.75rem;
        font-size: 1rem;
        font-weight: normal;
    }

    .bevy-tag.component-tag {
        color: oklch(0.85 0.1 310);
        background-color: oklch(0.475 0.1 310);
    }

    .bevy-tag.resource-tag {
        color: oklch(0.85 0.1 130);
        background-color: oklch(0.475 0.1 130);
    }

    .bevy-tag.event-tag {
        color: oklch(0.85 0.1 200);
        background-color: oklch(0.475 0.1 200);
    }

    .bevy-tag.plugin-tag {
        color: oklch(0.85 0.1 60);
        background-color: oklch(0.475 0.1 60);
    }
</style>
